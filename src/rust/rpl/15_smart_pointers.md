# Smart Pointers

## Pointer
- 메모리의 주소 값을 담고 있는 변수에 대한 일반적인 개념
- 러스트에서 가장 흔한 종류의 포인터는 참조자
- 값을 참조하는 것 외에 다른 어떤 특별한 능력도 없음

## Smart Pointer
- 포인터처럼 작동하지만 추가적인 메타데이터와 능력들도 가지고 있는 데이터 구조
- 참조자가 데이터를 오직 빌리기만 하는 포인터
- 많은 경우에서 스마트 포인터는 그들이 가리키고 있는 데이터를 소유
- 보통 구조체를 이용하여 구현
- 일반적인 구조체와 구분되는 특성은 바로 스마트 포인터가 Deref와 Drop 트레잇을 구현
- Deref trait
  - 스마트 포인터 구조체의 인스턴스가 참조자처럼 동작하도록 하여 참조자나 스마트 포인터 둘 중 하나와 함께 작동하는 코드를 작성 가능하게 함
- Drop trait
  - 스마트 포인터의 인스턴스가 스코프 밖으로 벗어났을 때 실행되는 코드를 커스터마이징 가능

## Using Box<T> to Point to Data on the Heap
- 가장 직관적인 스마트 포인터는 박스 (box) : Box<T> 타입
- 데이터를 스택이 아니라 힙에 저장할 수 있도록 해줌
- 스택에 남는 것은 힙 데이터를 가리키는 포인터
- 박스는 스택 대신 힙에 데이터를 저장한다는 점 외에는, 성능적인 오버헤드가 없음
- 여러 가지의 추가 기능 또한 가지고 있지 않음
- 사용 예
    ```rust
    fn main() {
        let b = Box::new(5);
        println!("b = {}", b);
    }
    ```
  - 5라는 값을 가리키는 Box의 값을 갖는 변수 b를 선언했는데, 여기서 5는 힙에 할당
  - 우리는 마치 이 데이터가 스택에 있었던 것과 유사한 방식으로 박스 내의 데이터에 접근
  - b가 main의 끝에 도달하는 것처럼 어떤 박스가 스코프를 벗어날 때, 할당은 해제
  - 할당 해제는 (스택에 저장된) 박스와 이것이 가리키고 있는 (힙에 저장된) 데이터 모두에게 발생

## Enabling Recursive Types with Boxes
- 러스트는 컴파일 타임에 어떤 타입이 얼마나 많은 공간을 차지하는지를 알 필요가 있음
- 컴파일 타임에는 크기를 알 수 없는 한 가지 타입이 바로 재귀적 타입 (recursive type)

## Treating Smart Pointers Like Regular References with the Deref Trait
- Deref 트레잇을 구현하는 것은 우리가 (곱하기 혹은 글롭 연산자와는 반대 측에 있는) 역참조 연산자 (dereference operator) * 의 동작을 커스터마이징 하는 것을 허용
